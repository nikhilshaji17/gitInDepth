Git = a distributed version control system

At it's core, git is like a key value store

key = the hash of the data. This is a SHA-1 function.
value = the data to be stored

The data provided will generate a 40 digit hexadecimal number.

This is also called a content addressable storage system, because the content generates the key.

Git stores data via blobs. They contain metadata about the blob itself, the size of the content,
  the delimiter and the actual content.

Git cannot store empty directories. This is because of a limitation in the staging area.

The reason why we can change branches so fast is because of git's key value storage design.
  1. A file that has the same content contains the same hash.
  2. When you switch from one branch to another, instead of having to fetch all the same files again
      whatever files have the same hash value as the one in your current branch remain the same.
  3. Files that are new or different are fetched. This way, git can quickly switch branches.

deltas => the changes between the previous version of your file and the new version
A Packfile stores the new object, and the deltas (the changes from the previous version).

Commits:

A commit points to a tree.

It contains metadata like:
 1. The author and commiter
 2. The date
 3. The message
 4. The parent commit.

The sha1 of the commit is the hash of all this info.

The three types of objects are the blob, the tree and the  commit.


PRIMEAGEN COURSE:

Short cuts to navigate the man pages:

j goes one line down
k goes one line up
d goes one half page down
u goes one half page up
/<term> will search for term
n goes to next search term
N goes to prev search term

Centralized version control:
You have your version of a file, which if you check out, can no longer be edited by anyone else,
  until you check the file in again.

Porcelain commands => high-level and plumbing commands => low-level

Commit = A point in time that represents the project in its entirety.
A commit represents the entire codebase.
The SHA is calculated by the author, date, contents of change and more.

Key terms:
index and staging are 2 interchangeable terms.

When you run git add, the files you add are hashed and stored as objects in the staging area,
  ready to be commited.

squash => To take multiple commits (say N), and "squash" them into 1 (or N - 1, or N - 2 and so on).

untracked -> staged -> tracked

remote => The same project repo, somewhere on another computer, from which you can push
  or pull changes from/to.

git is an acyclic graph. 

The .git folder contains all of the state and information of the git repo.

 --graph
           Draw a text-based graphical representation of the commit
           history on the left hand side of the output. This may cause
           extra lines to be printed in between commits, in order for the
           graph history to be drawn properly. Cannot be combined with
           --no-walk.

The reason we cannot directly cat an object is because it is compressed. Hence, we 
use the git cat-file command.

INPUT:
git cat-file -p 297bd49a46927a189d94e7efdae297e073ccd1f8

OUTPUT:
  tree a40cc902cd0a57eb2f7ee7f756224d2487547863
  parent d2fdca609f2e7c010f4ec231bb067be205052539
  author nikhilshaji17 <nikhilshaji17@gmail.com> 1764660181 +0400
  committer nikhilshaji17 <nikhilshaji17@gmail.com> 1764660181 +0400


tree => A tree is a directory, which contains one or more files.
blob => A blob is a file.

Config:
man git-config

To list out values, say from the config file:
git config --get-regexp <section-name>

OR 

git config --list | grep <section-name>

git config --get <section-name>.<section-key>

There is a global config file, and a local config file.

You can view the global file with the command:
git config --list --global


Branching:
man git-branch

git branch <branchname>

To delete a branch, use -d or -D.

Merge and Rebase:
Best common ancestor = merge base = The point where the 2 (or more) branches 
  start to diverge.


What rebase does is change where the commit pointer points to. This will change
  our graph from:

  B --- C                foo
 /
A --- D --- E --- X --- Y main 

to

                           B --- C                foo
                         /
A --- D --- E --- X --- Y                         main 

To use rebase:
1. Checkout to the branch you want to add to your target branch
2. Use git rebase <target_branch>

Pros:
When using rebase you can have a clean history with no merge commits. If you 
  are someone who uses git log a lot this can really help with searching.

Cons:
It alters history of a branch. That means that if you already had foo on a remote 
  git, you would have to force push it to the remote again.

In general:
merge on public branches 
rebase (if needed) on private branches

HEAD:
Everytime we change branches, HEAD points to that current branch.

Reflog:
The command git reflog just shows you where HEAD has been. (reflog = Reference logs)
We can use reflog to find the commit hash of a branch, then we can recreate it using:

git branch branch_name commit_hash_of_deleted_branch

Cherry-pick:
Given one or more existing commits, apply the change each one introduces,
recording a new commit for each. This requires your working tree to be clean
(no modifications from the HEAD commit).


Remote:
This just means the copy of the repo, somewhere else.

