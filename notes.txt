Git = a distributed version control system

At it's core, git is like a key value store

key = the hash of the data. This is a SHA-1 function.
value = the data to be stored

The data provided will generate a 40 digit hexadecimal number.

This is also called a content addressable storage system, because the content generates the key.

Git stores data via blobs. They contain metadata about the blob itself, the size of the content,
  the delimiter and the actual content.

Git cannot store empty directories. This is because of a limitation in the staging area.

The reason why we can change branches so fast is because of git's key value storage design.
  1. A file that has the same content contains the same hash.
  2. When you switch from one branch to another, instead of having to fetch all the same files again
      whatever files have the same hash value as the one in your current branch remain the same.
  3. Files that are new or different are fetched. This way, git can quickly switch branches.

deltas => the changes between the previous version of your file and the new version
A Packfile stores the new object, and the deltas (the changes from the previous version).

Commits:

A commit points to a tree.

It contains metadata like:
 1. The author and commiter
 2. The date
 3. The message
 4. The parent commit.

The sha1 of the commit is the hash of all this info.

The three types of objects are the blob, the tree and the  commit.


PRIMEAGEN COURSE:

Short cuts to navigate the man pages:

j goes one line down
k goes one line up
d goes one half page down
u goes one half page up
/<term> will search for term
n goes to next search term
N goes to prev search term

Centralized version control:
You have your version of a file, which if you check out, can no longer be edited by anyone else,
  until you check the file in again.

Porcelain commands => high-level and plumbing commands => low-level

Commit = A point in time that represents the project in its entirety.
A commit represents the entire codebase.
The SHA is calculated by the author, date, contents of change and more.

Key terms:
index and staging are 2 interchangeable terms.

When you run git add, the files you add are hashed and stored as objects in the staging area,
  ready to be commited.

squash => To take multiple commits (say N), and "squash" them into 1 (or N - 1, or N - 2 and so on).

untracked -> staged -> tracked

remote => The same project repo, somewhere on another computer, from which you can push
  or pull changes from/to.

git is an acyclic graph. 

The .git folder contains all of the state and information of the git repo.

 --graph
           Draw a text-based graphical representation of the commit
           history on the left hand side of the output. This may cause
           extra lines to be printed in between commits, in order for the
           graph history to be drawn properly. Cannot be combined with
           --no-walk.

The reason we cannot directly cat an object is because it is compressed. Hence, we 
use the git cat-file command.

INPUT:
git cat-file -p 297bd49a46927a189d94e7efdae297e073ccd1f8

OUTPUT:
  tree a40cc902cd0a57eb2f7ee7f756224d2487547863
  parent d2fdca609f2e7c010f4ec231bb067be205052539
  author nikhilshaji17 <nikhilshaji17@gmail.com> 1764660181 +0400
  committer nikhilshaji17 <nikhilshaji17@gmail.com> 1764660181 +0400


tree => A tree is a directory, which contains one or more files.
blob => A blob is a file.

Config:
man git-config

To list out values, say from the config file:
git config --get-regexp <section-name>

OR 

git config --list | grep <section-name>

git config --get <section-name>.<section-key>

There is a global config file, and a local config file.

You can view the global file with the command:
git config --list --global


Branching:
man git-branch

git branch <branchname>

To delete a branch, use -d or -D.
git branch = shows you the branches of only your local repo
git branch -a = shows you all the branches, including the remote repos.

Merge and Rebase:
Best common ancestor = merge base = The point where the 2 (or more) branches 
  start to diverge.


What rebase does is change where the commit pointer points to. This will change
  our graph from:

  B --- C                foo
 /
A --- D --- E --- X --- Y main 

to

                           B --- C                foo
                         /
A --- D --- E --- X --- Y                         main 

To use rebase:
1. Checkout to the branch you want to add to your target branch
2. Use git rebase <target_branch>

Pros:
When using rebase you can have a clean history with no merge commits. If you 
  are someone who uses git log a lot this can really help with searching.

Cons:
It alters history of a branch. That means that if you already had foo on a remote 
  git, you would have to force push it to the remote again.

In general:
merge on public branches 
rebase (if needed) on private branches

HEAD:
Everytime we change branches, HEAD points to that current branch.

Reflog:
The command git reflog just shows you where HEAD has been. (reflog = Reference logs)
We can use reflog to find the commit hash of a branch, then we can recreate it using:

git branch branch_name commit_hash_of_deleted_branch

Cherry-pick:
Given one or more existing commits, apply the change each one introduces,
recording a new commit for each. This requires your working tree to be clean
(no modifications from the HEAD commit).


Remote:
This just means the copy of the repo, somewhere else.

git remote add origin ../helloGit (We write this command from remote-git folder)
This command makes it such that remote-git now pushes and fetches from helloGit.

upstream => The repo that the workplace has (the source of truth, pull from here)

origin:
  Case A: When you are working on a personal project, and origin is your remote repo
    that means origin is your source of truth.
  Case B: When you are working on a group project (workplace), origin would be your
    forked repo, and upstream would be source of truth.

Git pull = Git fetch + git merge 
So when we git fetch, we just update the .git folder
We still need to merge the changes.

git fetch will fetch all the commits from the remote you have configured.

git pull <remote> <branch>

Stashing:

The stash is a stack of temporary changes.
You can make changes in the local repo, stash them, pull changes in from origin, 
  and then apply the stash to your local repo.

Stash takes every tracked change inside the index (staging area) and the working tree (repo)
  The command saves your local modifications away and reverts the working directory to match 
  the HEAD commit.

You can also add a message to your stash, similar to commit:
  git stash -m "Message here"

To show your stash:
  git stash list

To get the latest element from the stash:
  git stash pop 
  (OR)
  git stash pop --index <index_number>

Worktree => A copy of your repo, without all the weight of the repo.

"squash" your commits => What is meant by this is interactive rebase squash.

Without squash:
              E - F - G    topic
             /
A - B - C - D              master

With squash:
              EFG          topic
             /
A - B - C - D              master

Interactive rebasing allows you to edit your messages as well.
  So now, you can take all your commit, squash them together, and have a single clean message.

If there is a merge conflict, use git status to see what has gone wrong.

rerere:

reuse recorded resolutions
This allows you to record a resolution for a conflict, such that 
  the next time git comes across the conflict again, it can handle it automatically.

Use the command:

git checkout --ours <filename> 
// This one will keep the file from our branch

git checkout --theirs <filename>
// This one will keep their incoming changes

Do not mix merge and rebase. In general, rebase your own branches on your own repo. Merge on public branches.

In case of rebase, git checkout ours will give us their file. This is because we are looking from their perspective.
In case of merge, git checkout ours will keep our file.

